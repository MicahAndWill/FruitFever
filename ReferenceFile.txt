VARIABLE NAMING CONVENTIONS:

	-Mirroring images/animations:
	playerStill - original
	playerStillH - mirrored horizontally
	playerStillV - mirrored vertically
	playerStillHV - mirrored horizontally and vertically
	
_____________________________________________________________________________________________

BUTTON TYPES:

	0 - Play
	1 - Controls
	2 - Options
	3 - Multiplayer
	
	4 - Left Arrow
	5 - Right Arrow
	6 - Level boxes
_____________________________________________________________________________________________

ANIMATION TYPES:

	-1	-> N/A
	0	-> Player
	1	-> Swirl
	2	-> Fruit

_____________________________________________________________________________________________

BOUNDING BOXES IN THING CLASS:

	By default, the bounding box is identical to the location and the size of the image. But you can adjust the position of this bounding box. Ex: "boundaryLeft = -5;" would extend the left side of the bounding box over 5 pixels. The other 3 variables are logically called boundaryRight, boundaryTop, and boundaryBottom.
	
	Example of when this functionality will need to be used?
		-The player's various animations will need to adjust the bounding boxes (tongue sticking out is a lot wider than when the player is just standing still).
		-Circular enemies.. By bringing in the bounding box on each side by a bit, the collision checking would be a great deal more precise.
	
	Here's how to access the variables of the image and the bounding box (the underlying Rectangle, used to detect collisions):
	
		Image (these x and y values refer to the position in the world):
			The x position  --> imageX
			The y position	--> imageY
			The width		--> image.getWidth()*
			The height:		--> image.getHeight()*
			
		Bounding Box - Rectangle (these x and y values refer to the position on-screen):
			The x position  --> x or getX()*
			The y position	--> y or getY()*
			The width		--> width or getWidth()*
			The height:		--> height or getHeight()*
			
		*NOTE: The getters return a double value, so you may need to cast to int.
_____________________________________________________________________________________________

-CURRENT SCREEN VARIABLE:

	0 = Loading Game, 1 = Main Menu, 2 = Level Selection, 3 = Playing, 4 = Controls, 5 = Options, 6 = Multiplayer Playing

	The game is currently set to begin at the Main Menu (our final game will likely have a cool splashscreen though)

		public static int currentScreen = 1;

_____________________________________________________________________________________________

-LEVEL FILE STRUCTURE:

	Add a '+' character between each section 	

	BLOCKS (each Block also has an associated type/integer value, but this is not used for building the levels):

		Brownblock0 (0)  --> a
		Brownblock1 (1)  --> b
		Brownblock2 (2)  --> c
		Brownblock3 (3)  --> d
		Brownblock4 (4)  --> e
		BlueBlock   (5)  --> f
		YellowBlock (6)  --> g
		RedBlock    (7)  --> h
		GreenBlock  (8)  --> i
		PurpleBlock (9)  --> j
		GrayBlock   (10) --> k
		WhiteBlock0 (11) --> l
		WhiteBlock1 (12) --> m
		WhiteBlock2 (13) --> n
		BlackBlock  (14) --> o

		GrassBrownblock0 (0)  --> A
		GrassBrownblock1 (1)  --> B
		GrassBrownblock2 (2)  --> C
		GrassBrownblock3 (3)  --> D
		GrassBrownblock4 (4)  --> E
		GrassBlueBlock   (5)  --> F
		GrassYellowBlock (6)  --> G
		GrassRedBlock    (7)  --> H
		GrassGreenBlock  (8)  --> I
		GrassPurpleBlock (9)  --> J
		GrassGrayBlock   (10) --> K
		GrassWhiteBlock0 (11) --> L
		GrassWhiteBlock1 (12) --> M
		GrassWhiteBlock2 (13) --> N
		GrassBlackBlock  (14) --> O
		
		FRUIT are also put into this section:
		
			BlueBerry		--> 0
			RedBerry		--> 1
			
		The player's startng position is also put into this section:
		
			Player			--> @

	SCENERY (each Scenery object also has an associated type/integer value, but this is not used for building the levels):
	
		-TOP ROW:
		Wide Plant (V-Shaped)	(0)  --> a
		Weeds 					(1)  --> b
		Yellow Flower			(2)  --> c
		Pink Flower				(3)  --> d
		Plant 					(4)  --> e
		Tree (No Blossoms)		(5)  --> f
		Tree (Blossoms)			(6)  --> g
		
		-BOTTOM ROW:
		Tree Trunk				(7)  --> h
		Grass					(8)  --> i
		Plant2					(9)  --> j
		Marijuana Plant			(10) --> k
		Plant3 					(11) --> l
		Mushroom (Small)		(12) --> m
		Mushroom (Medium)		(13) --> n
		Mushroom (Large)		(14) --> o
		
	ENEMIES:

		The accepted format for declaring an enemy is to replace
		a '-' character with <Enemy-Type Race-Color left right up down> in the
		for format of <a-z a-z int , int , int , int>. 

		NOTE: If all left, right, up & down are all zero then the enemy assumes 
		default behavior. 

		Examples:

		------
		--<ab4,12,0,0>---
		------

		^^^creates an enemy of type 'a' (triangle) of Color/Race 'b' (yellow) that
		can move 4 units left of its original position and 12 units right (total of 17 units). 


		-----
		<ba0,0,5, 6>--<ba0,0,5,2>--
		-----

		^^^ Creates Two enemies of type 'b' (flying circle) and Race/Color 'a' (blue).
		One moves between its original position and 5 units down and the other moves up 5
		and down 2 (covers a total of 8 units)
		
_____________________________________________________________________________________________

-CLASS HIERARCHY:
	
	-GraphicsProgram (part of acm.program.*)
		-FruitFever (implements MouseMotionListener so that mouseDragged and mouseMoved methods can be used)
	
	-GameStarter
	
	-Data
	
	-ImageTransformer
	
	-Rectangle (part of java.awt.*)
		-Thing
			-Block
			-Button
			-Scenery
			-Animation
				-MovingAnimation
					-Player
		
_____________________________________________________________________________________________

HELPFUL NOTES BY MICAH:

	1. Since we have many different classes in our ArrayList<Thing>, we need some way of checking to see what type of object we are dealing with. Here's an example of an easy way to do that:

		for(Thing obj : things)
			if(obj instanceof MovingAnimation)
				System.out.println("This is either a MovingAnimation or one of its subclasses.");
				
	2. viewX and viewY are the variables used to store the current view of the screen. The following code fragment would move the entire view to the right 10 pixels and up 5 pixels;
		
		viewX += 10;
		viewY -= 5;
		
	3. The inheritance structure that was updated on April 23 means that essentially everything in the game is
	a subclass of the Thing class, which extends Rectangle (not GRectangle, since we don't need Double precision).
	This enables us to easily check for collisions between objects. The Rectangles are even updated if an animated
	image is changing sizes. In the FruitFever class, we currently have three ArrayLists holding our objects. Note
	that since both Block and Button is a subclass of Thing, there's nothing stopping us from putting them all in
	the ArrayList of Things, but putting them in a separate list makes them easier to access (you won't need to
	check to see what instanceOf you're dealing with). We will most likely end up further dividing the
	"ArrayList<Thing> things" into further ArrayLists (or HashMaps, etc.) for that very reason. However, being able
	to combine these different classes into the same array adds a lot of flexibility into our program, and can
	greatly reduce the complexity and length of our code (since we are easily able to generalize).
	
		public static Block[] blocks;
		public static ArrayList<Thing> things = new ArrayList<Thing>();
		public static ArrayList<Button> buttons = new ArrayList<Button>();


________________________________________________________________________________________________________

HELPFUL NOTES BY WILL


1. How makeSceneryTemplate.py works and what it is used for:
   
   Say you just made a huge level in levels.txt and now you want to place some scenery on it.
   Instead of guessing the positions of the blocks in the block layer you can use the mkTemp.py to generate a template for you. This works by interpreting any sprite in the block layer as a '#' (which I added to be a transprent block like '-') besides the '-'. 

   How to make it work:

   Paste the block layer in the file called 'sceneryTemplateFile.txt' and then run the python script in the terminal with $ python mkTemp.py then open the 'sceneryTemplateFile.txt' to see the template made. Example:

   In levels.txt      sceneryTemplateFile.txt       sceneryTemplateFile.txt        

   ---d---                ---d---                          ---#---                          
   ---a-a-                ---a-a-   $ python mkTemp.py     ---#-#-                           
   --abba-  ----->        --abba-            ------>       --####-                       
   -acc---                -acc---                          -###---
   +                                                                                    
   -------                                                                             
   -------                                                                             
   -------                                                                      
   -------                                                                      

   Now you have a file with an outline of the blocks in the block layer 













































