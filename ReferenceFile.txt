BUTTON TYPES:

	0 - Play
	1 -
	2 -
	3 -
	
	4 - Left Arrow
	5 - Right Arrow
	6 - Level boxes
	
_____________________________________________________________________________________________________________

BOUNDING BOXES IN THING CLASS:

	By default, the bounding box is identical to the location and the size of the image. But you can adjust the position of this bounding box. Ex: "boundaryLeft = -5;" would extend the left side of the bounding box over 5 pixels. The other 3 variables are logically called boundaryRight, boundaryTop, and boundaryBottom.
	
	Example of when this functionality will need to be used?
		-The player's various animations will need to adjust the bounding boxes (tongue sticking out is a lot wider than when the player is just standing still).
		-Circular enemies.. By bringing in the bounding box on each side by a bit, the collision checking would be a great deal more precise.
	
	Here's how to access the variables of the image and the bounding box (the underlying Rectangle, used to detect collisions):
	
		Image:
			The x position  --> imageX
			The y position	--> imageY
			The width		--> image.getWidth()*
			The height:		--> image.getHeight()*
			
		BoundingBox (Rectangle):
			The x position  --> x or getX()*
			The y position	--> y or getY()*
			The width		--> width or getWidth()*
			The height:		--> height or getHeight()*
			
		*NOTE: The getters return a double value, so you may need to cast to int.
_____________________________________________________________________________________________________________

-CURRENT SCREEN VARIABLE:

	0 = Loading Game, 1 = Main Menu, 2 = Level Selection, 3 = Playing, 4 = Controls, 5 = Options, 6 = Multiplayer Playing

	The game is currently set to begin at the Main Menu (our final game will likely have a cool splashscreen though)

		public static int currentScreen = 1;

_____________________________________________________________________________________________________________

-LEVEL FILE STRUCTURE:

	Add a '+' character between each section 	

	BLOCKS (each Block also has an associated type/integer value, but this is not used for building the levels):

		Brownblock0 (0)  --> a
		Brownblock1 (1)  --> b
		Brownblock2 (2)  --> c
		Brownblock3 (3)  --> d
		Brownblock4 (4)  --> e
		BlueBlock   (5)  --> f
		YellowBlock (6)  --> g
		RedBlock    (7)  --> h
		GreenBlock  (8)  --> i
		PurpleBlock (9)  --> j
		GrayBlock   (10) --> k
		WhiteBlock0 (11) --> l
		WhiteBlock1 (12) --> m
		WhiteBlock2 (13) --> n
		BlackBlock  (14) --> o

		GrassBrownblock0 (0)  --> A
		GrassBrownblock1 (1)  --> B
		GrassBrownblock2 (2)  --> C
		GrassBrownblock3 (3)  --> D
		GrassBrownblock4 (4)  --> E
		GrassBlueBlock   (5)  --> F
		GrassYellowBlock (6)  --> G
		GrassRedBlock    (7)  --> H
		GrassGreenBlock  (8)  --> I
		GrassPurpleBlock (9)  --> J
		GrassGrayBlock   (10) --> K
		GrassWhiteBlock0 (11) --> L
		GrassWhiteBlock1 (12) --> M
		GrassWhiteBlock2 (13) --> N
		GrassBlackBlock  (14) --> O

	SCENERY (each Scenery object also has an associated type/integer value, but this is not used for building the levels):
	
		NOTE: Will, I gave these (poor) names, can you give them better names, since you know exactly what they are?

		-TOP ROW:
		Wide Plant (V-Shaped) 	(0)  --> a
		Weeds 					(1)  --> b
		Yellow Flower 		  	(2)  --> c
		Pink Flower 		  	(3)  --> d
		Plant 				  	(4)  --> e
		Tree (No Blossoms) 	  	(5)  --> f
		Tree (Blossoms) 	  	(6)  --> g
		
		-BOTTOM ROW:
		Tree Trunk				(7)  --> h
		Grass 				  	(8)  --> i
		Plant2 				  	(9)  --> j
		Marijuana Plant 	  	(10) --> k
		Plant3 					(11) --> l
		Mushroom (Small) 		(12) --> m
		Mushroom (Medium) 		(13) --> n
		Mushroom (Large) 		(14) --> o
		
	ENEMIES:

		The accepted format for declaring an enemy is to replace
		a '-' character with <Enemy-Type Race-Color left right up down> in the
		for format of <a-z a-z int , int , int , int>. 

		NOTE: If all left, right, up & down are all zero then the enemy assumes 
		default behavior. 

		Examples:

		------
		--<ab4,12,0,0>---
		------

		^^^creates an enemy of type 'a' (triangle) of Color/Race 'b' (yellow) that
		can move 4 units left of its original position and 12 units right (total of 17 units). 


		-----
		<ba0,0,5, 6>--<ba0,0,5,2>--
		-----

		^^^ Creates Two enemies of type 'b' (flying circle) and Race/Color 'a' (blue).
		One moves between its original position and 5 units down and the other moves up 5
		and down 2 (covers a total of 8 units)
		
_____________________________________________________________________________________________________________

-CLASS HIERARCHY:
	
	-GraphicsProgram (part of acm.program.*)
		-FruitFever (implements MouseMotionListener so that mouseDragged and mouseMoved methods can be used)
	
	-GameStarter
	
	-Data
	
	-Rectangle (part of java.awt.*)
		-Thing
			-Block
			-Button
			-Scenery
			-Animation
				-MovingAnimation
					-Swirl (temporary)
					-BlueEnemy (temporary)
		
_______________________________________________________________________________________________________________

HELPFUL NOTES BY MICAH:

	1. Since we have many different classes in our ArrayList<Thing>, we need some way of checking to see what type of object we are dealing with. Here's an example of an easy way to do that:

		for(Thing obj : things)
			if(obj instanceof MovingAnimation)
				System.out.println("This is either a MovingAnimation or one of its subclasses.");
				
	2. viewX and viewY are the variables used to store the current view of the screen. The following code fragment would move the entire view to the right 10 pixels and up 5 pixels;
		
		viewX += 10;
		viewY -= 5;
		
	3. The inheritance structure that was updated on April 23 means that essentially everything in the game is
	a subclass of the Thing class, which extends Rectangle (not GRectangle, since we don't need Double precision).
	This enables us to easily check for collisions between objects. The Rectangles are even updated if an animated
	image is changing sizes. In the FruitFever class, we currently have three ArrayLists holding our objects. Note
	that since both Block and Button is a subclass of Thing, there's nothing stopping us from putting them all in
	the ArrayList of Things, but putting them in a separate list makes them easier to access (you won't need to
	check to see what instanceOf you're dealing with). We will most likely end up further dividing the
	"ArrayList<Thing> things" into further ArrayLists (or HashMaps, etc.) for that very reason. However, being able
	to combine these different classes into the same array adds a lot of flexibility into our program, and can
	greatly reduce the complexity and length of our code (since we are easily able to generalize).
	
		public static Block[] blocks;
		public static ArrayList<Thing> things = new ArrayList<Thing>();
		public static ArrayList<Button> buttons = new ArrayList<Button>();
